
# Specification

Here is some architectural knowledge to generate application by Rutile, 
and to use generated code for your concrete application.

## Schema

Rutile requires data world composed of Entity and Collection.

This presupposition provides all of the code generation, both in server and client.
If you are familiar with EJB, Enterprise Java Beans, you have an experience this kind of database design.

This design manner simplify and abstract data and application at all points.

### Entity

```
# Entity (Entity Name)
sequence:entitySeq(num)

	field*		type*	name*			search*		valid*		tags
	-----------+-------+---------------+-----------+-----------+---------------------
	entityID	int4	EntityID		SEARCH		VALID
	field1		TYPE	Field1 Name		SEARCH		VALID		TAGS
	field2		TYPE	Field2 Name		SEARCH		VALID		TAGS
	foreignID	int4	Foreign Name	SEARCH,join	VALID		helper:Segment/Entity
	  :			  :		  :				  :			  :			  :
```

The entityID is a sequential number generated by entitySeq defined above.
This is sometimes called as surrogate key or pseudo key.
Composite key is not allowed.

Its name should be a entity name starting with lower case character and with trailing ID.
The primary key might be written in entity<b>Id</b> in some other system.
But Rutile uses entity<b>ID</b> to explicitly define it is an ID.

The foreignID means a primary key of foreign entity.
This should be literally the key.

The foreign key usually have join and helper option in schema definition. 
This definition does not constraint your physical database, just a logical constraint.
So that you can define external database entity.

Generated sql file to setup your database does not have any FK constraint.
You can design your physical database as you like.

(You have to add join property for search section, and helper tag for tags section at the same time.
This is historical reason.)

### Collection

```
+-----------+                     +-----------+
| Collector |â—†---------+----------| Collected |
+-----------+          |          +-----------+
               +-------+--------+
               | Junction table |
               +----------------+


* CollectorCollected (Collector-Collected)

	collector/collected*					type*
	---------------------------------------+------
	CollectorSegment/Collector.collectorID	int4
	CollectedSegment/Collected.collectedID	int4
```

Collection means Collector has Collected entity, in other word, many-many relationship.
This is represented by junction table.

All of business entities might be defined by this style of database design.


## Client Server Protocol

```
+--------+                       +--------+
| Client |<---{app} WebSocket--->| Server |
+--------+                       +--------+
```

To use generated server function, client have to connect to the server with WebSocket,
and request a small object encapsulating application message.
This is called *app*.

Rutile generates SCRUD server functions as a method for each entity.
Those are named as, search, launch, get, register and remove.

Therefore, all operation for the specific entity can be described as "Segment/Entity.method".
This is a key of app, named as *apptag*.

The app should have apptag for the identifier of the server side application function.
Client makes a request to call the function with parameter for this identifier.

```javascript
var app = { apptag:"Segment/Entity.method", params:{parameters}, serial:1 };
```

For example, to get instances of "Product/Product" its productID is 1,2 and 3 will be composed as:

```javascript
var app = { apptag:"Product/Product.get", params:[1,2,3], serial:1 };
```

The last element, serial, is a unique number in the client instance, to determine callback.

Actual request the *app* is contained in a context object, 
that is bidirectional root message object between client and server.

```javascript
var context = { request:[ app1, app2, ... ], serial:1 };
```

To send make request to the server, you have to pack app set with name request, and with serial number unique in you application instance.

All apps are executed in the order you defined in the request array.
After all, server returns context with response set with name of your request serial number.

```javascript
var context = { 'response,serial':[ app1, app2, ... ] };
```

Those responses also having apptag and serial, and the actual result is in *result* property instead of *params*.
Client can pick up callback for each response by them.

Following is general description of request and response object for each method.

### search

The search method accepts an object having keys, constraint, logic, orderby, scope and optionally expand.

The constraint keyword is a main keyword for search query.
This is an object containing search target and constraint value.

For example, searching entities "Product/Product", its name like "Apple" or "Orange", 
and its price is between 100 and 200, can be defined as:

```javascript
var app = {
	apptag: "Product/Product.search",
	params: {
		constraint: {
			"Product/Product.name(like)" : { values:["Apple","Orange"], logic:'OR' },
			"Product/Product.price(num)" : { min:100, max:200 }
		},
		logic : 'AND',
		orderby: { price : 'desc' },
		expand : 2
	}
};
```

The constraint keyword is composed of target segment, entity, field and search type in the brackets.
The expand keyword is depth of result instantiation, that means how many times recursively instantiate foreign keys.

Acceptable constraint format for each search type is following:

| type      | format                       | note                                          |
|:----------|:-----------------------------|:----------------------------------------------|
| key       | { values:[V], logic:AND/OR } | V: string or number                           |
| like      | { values:[V],logic:AND/OR }  | V: string or number                           |
| num       | { min:N, max:N }             | N: number, one or both                        |
| date      | { min:D, max:D }             | D: string represent date, one or both         |
| timestamp | { min:T, max:T }             | T: string represent timestamp, one or both    |
| nearby    | { values:[A], logic:AND/OR } | A: {centroid:'POINT(LON LAT)',distance:meter} |
| area      | { values:[A], logic:AND/OR } | A: {area:'POLYGON((LON LAT,...))'}            |

If you define *orderby* for the field, 
you can add a orderby keyword for your app request with sort target field as its key and desc or asc for its value.

The keyword logic can be defined for each search type and whole search object.

And if you define join for your field, searching foreign field can be available.
For example:

```javascript
var app = {
	apptag : "Order/OrderItem.search",
	params : {
		constraint: {
			"Order/OrderItem.name(like)" : { values:["Apple","Orange"] },
			"Product/Product.price(num)" : { min:100, max:200 }
		}
	}
};
```

If it contains external segment, server function will be automatically generated as dblink query.

```javascript
var instances = context['response,serial'][i].result;
```

The result set of search method is an array of instances.
You can get this array by app.result.

No implementation is generated for the Collection.

### launch

The launch method does not require any kind of parameters, just call with empty object.

```javascript
var app = { apptag:"Product/Product.launch", params:{}, serial:1 };
```

The result app object has a single object in the result property.

```javascript
var instance = context['response,serial'][i].result;
```

Retuned instance can be Entity and Collection both.

### get

The get method accepts a array of IDs you want to get instance.

```javascript
var app = { apptag:"Product/Product.get"  params:{ ids:[1,2,3], expand:1 }, serial:1 };
```

You can define depth of instantiation as expand.
The value expand:1 means do not load foreign entity, 
2 means instantiate foreign entity linked by foreign key field in the entity if it is defined.
3 means, and so on.

The result app is also having a array of instances.

```javascript
var instances = context['response,serial'][i].result;
```

Those instances can be both Entity and Collection.

### register

The register method accepts an object having keys, entities and bulk.

The keyword entities is an array of object that represent instance.

```javascript
var product = { productID:1, name:"Apple", price:100 } ;

var app = { apptag:"Product/Product.register", params:{ entities:[product], bulk:true  }, serial:1 }
```

The bulk flags means a selection for saving entire entity or individual fields value.
If the bulk flag is false, you can save individual field value.
Otherwise, server logic will fail if the instance does not have all required field value.
Even with the flag true, register method requires at least its primary key.

The result app object includes all saved instance.

```javascript
var instances = context['response,serial'][i].result;
```

Above described description is same for the Collection.

```javascript
var productProductImage = { productID:1, collection:[1,2,3] };

var app = { 
	apptag:"Product/ProductProductImage.register",
	params:{ entities:[productProductImage] },
	serial:1
};
```

But the bulk option is not affect in the Collection saving.

### remove

The remove method accepts a array of IDs you want to delete instance.

```javascript
var app = { apptag:"Product/Product.remove"  params:{ ids:[1,2,3], expand:1 }, serial:1 };
```

This method does not remove foreign entities recursively.
Therefore, if your entity has foreign entity only stand with the entity, you have to remove those entities independently.

The result app object contains removed IDs.

```javascript
var ids = context['response,serial'][i].result;
```

If you remove Collection, the semantics is different from Entity.
The remove method of Collection removes all of the entry in the junction table.
Therefore, if you want to remove a part of a collection,
at first remove all, then save the rest you want to leave.


## Server

Rutile's server side application is based on traditional container.

The container provides data persistent and object cacheing under the database transaction.
This is synchronous.

### Container

```
				           data persistent

       +-----------+           +-----+
       | Container +-----+-----+ DB1 |
       +-----+-----+     |     +-----+
             |           |   
object cache |           |     +-----+
             |           +-----+ DB2 |
         +---+---+       :     +-----+
         | Redis |       :
         +-------+
```

The container provides object cacheing, data persistent and transaction.

Container-object can be available from ContainerFactory defined in your generated package.
And connection information can be availalbe in the file generaged <APP_NAME>Server/<APP_NAME>Config/<APP_NAME>Config.js.
There is some default information defained, edit it for your env.

You can get container object for each database segment by specifying segment name.
The other way, you can bind multi-segment or all your segemtns.

```javascript
// specific segment
var container = ContainerFactory.getContainer('Segment1');

// multi-segment
var container = ContainerFactory.getContainer('Segment1','Segment2',...);

// all segments
var container = ContainerFactory.getContainer();

container.connect();
```

To use container, you must call init method to clean up cached instances that was used by previous session.

```javascript
container.init();
```

Transaction can be managed by transaction object made by container.
If the container bind multiple segments, transaction is also binded.

To start transaction, just call begin method.
The default is auto-commit mode.

You can set transaction isolation level and auto-commit mode individually.
And usual method is available.

You have to commit and close your transaction after your work.
Un-commited transaction will be aborted at the end of session.

```javascript
var tx = container.getTransaction();
tx.begin();

tx.setAutoCommit();
tx.isolationLebelSerializable();

// your works here

tx.commit();
tx.rollback();
tx close();
```

Object cache is provied by Redis.
It minimizes database access, and and makes instances for the same model for the same id identical in your session,
but does not provide any transaction.

```
var instance1 = Model.instantiate(1);
var instance2 = Model.instantiate(1);

instance1 === instance2; // true
```

### Logic

```
+----------+
| Frontend | (server.js)
+---+------+
    |
	| find a logic for the app
	| 
    |    +---------+
	+--->|  Logic  |
         +---------+
```

The entry point of server function is server.js, the frontend trigger for your app.

The server looks for appropriate application logic for requested apptag from LogicFactory that is generated in you server package.
The logic found by server is a function object that implement SCRUD.

```javascript
var method = LogicFactory.getMethod(apptag);
method(context,app);
```

The method, function object, gets context object and responsible app object.
The concrete implementation is provided by model.


### Model

Model class is preliminary generated according to your schema definition.
To manage your entity or collection, at first get a model class from your generated ModelFactory.
And then, instantiate by ID.

```javascript
var ModelFactory = APP_NAME.getModelFactory();
var EntityModel = ModelFactory.getModel('Segment/Entity');

var instance = EntityModel.instantiate(id);
```

Collection instance can be get in the same manner.

All of the model instances are managed by the container.
Therefore, as described above, the instance is always same object in the session.

Model implements concrete SCRUD function for the Entity and Collection.
Functions *SCR*, search and create, are defined as static method.
The rest *UD*, update and delete, are defined as instance method.

The life cycle of data persistent is following.

```javascript
var ids = Model.search(query);     // S:search
var id = Model.publishID();        // C:create
var instance = Model.instance(id); // R:read
instance.save();                   // U:update
instance.delete();                 // D:delete
```

### Sanitizing phase

The model implementation automatically sanitize you input data. 
This logic is automatically generated by your data type.

```javascript
instance.field = value;
```

For example, if you set string value for the field being numeric type field,
instance does not accept you input.

Indeed, this function simply sanitize the value, therefore no exception has been occurred.
In this case, the field will become 0.

| type      | sanitizing                              | default    |
|:----------|:----------------------------------------|:-----------|
| int       | evaluate as number                      | 0          |
| int2      | evaluate as number                      | 0          |
| int4      | evaluate as number                      | 0          |
| text      | evaluate as string                      | ''         |
| date      | evaluate as Date object, then stringify | null       |
| timestamp | evaluate as Date object, then stringify | null       |
| geography | evaluate as string                      | ''         |

Type geography is simply evaluated as string, not checked as POINT format.


### Validation phase

You can check whether your instance is having valid field data as you defined in schema definition.
This is provided by instance method *valid*.

```javascript
instance.valid();

instance.valid('fieldName');
```

Calling valid method without argument checks all field.
Otherwise, define a field name you want to check.
Both returns true or false.

| valid           | validation                                            |
|:----------------|:------------------------------------------------------|
| notNull         | true if some data in there                            |
| positiveValue   | true if the value is positive                         |
| negativeValue   | true if the value is negative                         |
| timestampString | true if the value is formatted as timestamp style     |
| dateString      | true if the value is formatted as date style          |
| emailString     | true if the value is formatted as email style         |
| geographyPoint  | true if the value is formatted as PostGIS point style | 


### Constraint

Constraint is a internal representation of search query.

Rutile generates query compiler for each entity named SQLMaker.
It gets the request object created by UI, described in above, 
and makes intermediate constraint objects, then makes sql expression of them.

All of query elements are preliminary generated as class definition.

For example, 
searching Product/Product entity, its product class name likes some value, under condition of Product/Product.productClassID is defined with helper Product/ProductClass, is generated as a file of:

```
Constraint/Product/Product/SelectbyProductClassProductClassNameLike.js
```

The format is:

```
Constraint/<Traget Segment>/<Target entity>/Selectby<Search entity><Search field><Search type>.js
```

This is why you have to define unique entity name across all segments.

(Of course the file name can be generated as including search segment, but not nowadays...)

### Component overriding (Impl)

Rutile generates symmetric package for your main APP_NAME package named <APP_NAME>Impl under the same directory of it.

The package has symmetric directory structure for the main package.
You can override module by putting override module into the appropriate location and modify Factory being there.

For example, following module overrides ProductImage model definition of DemoShop schema.

```javascript
var DemoShop = require('DemoShop');
var ModelFactory = DemoShop.getModelFactory();
var ProductImageModel = ModelFactory.getModel('Product/ProductImage');
var ParentConstructor = ProductImageModel.getClass;

function ModelConstructor(){
	var instance = new ParentConstructor(arguments);
	
	// wrapping the save method
	var orig_save = instance.save;
	instance.save = function(){
		console.log("I am save method, wrapped by implementation!");
		orig_save();
	};
	
	return instance;
}

module.exports = {
	getClass      : ModelConstructor,                   // override
	publishID     : ProductImageModel.publishID,        // delegate this function to the parent
	instance      : ProductImageModel.instantiate,      // delegate this function to the parent
	search        : ProductImageModel.search,           // delegate this function to the parent
	ids           : ProductImageModel.ids,              // delegate this function to the parent
	fieldManifest : ProductImageModel.getFieldManifest, // delegate this function to the parent
};
```

## Client

[FIG]

### Model

### CentralDispatch

### NotificationCenter

### KitchenSink made by Componet
### Component made by Framework

### EditFormGroup
### SearchFormGroup

### List(Reusable)
### Editor(Reusable)
### SearchForm(Reusable)






