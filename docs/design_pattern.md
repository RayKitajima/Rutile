
# Design pattern

Here is some architectural knowledge to generate application by Rutile, 
and to use generated code for your concrete application.

## Schema

Rutile requires data world composed of Entity and Collection.

This presupposition provides all of the code generation, both in server and client.
If you are familiar with EJB, Enterprise Java Beans, you have an experience this kind of database design.

### Entity

```
# Entity (Entity Name)
sequence:entitySeq(num)

	field*		type*	name*			search*		valid*		tags
	-----------+-------+---------------+-----------+-----------+---------------------
	entityID	int4	EntityID		SEARCH		VALID
	field1		TYPE	Field1 Name		SEARCH		VALID		TAGS
	field2		TYPE	Field2 Name		SEARCH		VALID		TAGS
	foreignID	int4	Foreign Name	SEARCH,join	VALID		helper:Segment/Entity
	  :			  :		  :				  :			  :			  :
```

The entityID is a sequential number generated by entitySeq defined above.
This is sometimes called as surrogate key or pseudo key.
Composite key is not allowed.

Its name should be a entity name starting with lower case character and with trailing ID.
The primary key might be written in entity<b>Id</b> in some other system.
But Rutile uses entity<b>ID</b> to explicitly define it is an ID.

The foreignID means a primary key of foreign entity.
This should be literally the key.

The foreign key usually have join and helper option in schema definition. 
This definition does not constraint your physical database, just a logical constraint.
So that you can define external database entity.

Generated sql file to setup your database does not have any FK constraint.
You can design your physical database as you like.

(You have to add join property for search section, and helper tag for tags section at the same time.
This is historical reason.)

### Collection

```
+-----------+                     +-----------+
| Collector |â—†---------+----------| Collected |
+-----------+          |          +-----------+
               +-------+--------+
               | Junction table |
               +----------------+


* CollectorCollected (Collector-Collected)

	collector/collected*					type*
	---------------------------------------+------
	CollectorSegment/Collector.collectorID	int4
	CollectedSegment/Collected.collectedID	int4
```

Collection means Collector has Collected entity, in other word, many-many relationship.
This is represented by junction table.

All of business entities might be defined by this style of database design.


## Client Server Protocol

```
+--------+                       +--------+
| Client |<---{app} WebSocket--->| Server |
+--------+                       +--------+
```

To use generated server function, client have to connect to the server with WebSocket,
and request a small object encapsulating application message.
This is called *app*.

Rutile generates SCRUD server functions as a method for each entity.
Those are named as, search, launch, get, register and remove.

Therefore, all operation for the specific entity can be described as "Segment/Entity.method".
This is a key of app, named as *apptag*.

The app should have apptag for the identifier of the server side application function.
Client makes a request to call the function with parameter for this identifier.

```
var app = { apptag:"Segment/Entity.method", params:{parameters}, serial:serial };
```

For example, to get instances of "Product/Product" its productID is 1,2 and 3 will be composed as:

```
var app = { apptag:"Product/Product.get", params:[1,2,3], serial:1 };
```

The last element, serial, is a unique number in the client instance, to determine callback.

Actual request the *app* is contained in a context object, 
that is bidirectional root message object between client and server.

```
context:{ request:[ app1, app2, ... ] }
```

All apps are executed in the order you defined in the request array.
After all, server returns context with response set.

```
context:{ response:[ app1, app2, ... ] }
```

Those responses also having apptag and serial, and the actual result is in *result* property instead of *params*.
Client can pick up callback for each response by them.

Following is general description of request and response object for each method.

### search

The search method accepts an object having keys, constraint, logic, orderby, scope and optionally expand.

The constraint keyword is a main keyword for search query.
This is an object containing search target and constraint value.

For example, searching entities "Product/Product", its name like "Apple" or "Orange", 
and its price is between 100 and 200, can be defined as:

```
var app = {
	apptag: "Product/Product.search",
	params: {
		constraint: {
			"Product/Product.name(like)" : { values:["Apple","Orange"], logic:'OR' },
			"Product/Product.price(num)" : { min:100, max:200 }
		},
		logic : 'AND',
		orderby: { price : 'desc' },
		expand : 2
	}
};
```

The constraint keyword is composed of target segment, entity, field and search type in the brackets.
The expand keyword is depth of result instantiation, that means how many times recursively instantiate foreign keys.

Acceptable constraint format for each search type is following:

| type      | format                       | note                                          |
|:----------|:-----------------------------|:----------------------------------------------|
| key       | { values:[V], logic:AND/OR } | V: string or number                           |
| like      | { values:[V],logic:AND/OR }  | V: string or number                           |
| num       | { min:N, max:N }             | N: number, one or both                        |
| date      | { min:D, max:D }             | D: string represent date, one or both         |
| timestamp | { min:T, max:T }             | T: string represent timestamp, one or both    |
| nearby    | { values:[A], logic:AND/OR } | A: {centroid:'POINT(LON LAT)',distance:meter} |
| area      | { values:[A], logic:AND/OR } | A: {area:'POLYGON((LON LAT,...))'}            |

If you define *orderby* for the field, 
you can add a orderby keyword for your app request with sort target field as its key and desc or asc for its value.

The keyword logic can be defined for each search type and whole search object.

And if you define join for your field, searching foreign field can be available.
For example:

```
var app = {
	apptag : "Order/OrderItem.search",
	params : {
		constraint: {
			"Order/OrderItem.name(like)" : { values:["Apple","Orange"] },
			"Product/Product.price(num)" : { min:100, max:200 }
		}
	}
};
```

If it contains external segment, server function will be automatically generated as dblink query.

```
var instances = context.response[i].result;
```

The result set of search method is an array of instances.
You can get this array by app.result.

No implementation is generated for the Collection.

### launch

The launch method does not require any kind of parameters, just call with empty object.

```
var app = { apptag:"Product/Product.launch", params:{}, serial:1 };
```

The result app object has a single object in the result property.

```
var instance = context.response[i].result;
```

Retuned instance can be Entity and Collection both.

### get

The get method accepts a array of IDs you want to get instance.

```
var app = { apptag:"Product/Product.get"  params:{ ids:[1,2,3], expand:1 }, serial:1 };
```

You can define depth of instantiation as expand.
The value expand:1 means do not load foreign entity, 
2 means instantiate foreign entity linked by foreign key field in the entity if it is defined.
3 means, and so on.

The result app is also having a array of instances.

```
var instances = context.response[i].result;
```

Those instances can be both Entity and Collection.

### register

The register method accepts an object having keys, entities and bulk.

The keyword entities is an array of object that represent instance.

```
var product = { productID:1, name:"Apple", price:100 } ;

var app = { apptag:"Product/Product.register", params:{ entities:[product], bulk:true  }, serial:1 }
```

The bulk flags means a selection for saving entire entity or individual fields value.
If the bulk flag is false, you can save individual field value.
Otherwise, server logic will fail if the instance does not have all required field value.
Even with the flag true, register method requires at least its primary key.

The result app object includes all saved instance.

```
var instances = context.response[i].result;
```

Above described description is same for the Collection.

```
var productProductImage = { productID:1, collection:[1,2,3] };

var app = { 
	apptag:"Product/ProductProductImage.register",
	params:{ entities:[productProductImage] },
	serial:1
};
```

But the bulk option is not affect in the Collection saving.

### remove

The remove method accepts a array of IDs you want to delete instance.

```
var app = { apptag:"Product/Product.remove"  params:{ ids:[1,2,3], expand:1 }, serial:1 };
```

This method does not remove foreign entities recursively.
Therefore, if your entity has foreign entity only stand with the entity, you have to remove those entities independently.

The result app object contains removed IDs.

```
var ids = context.response[i].result;
```

If you remove Collection, the semantics is different from Entity.
The remove method of Collection removes all of the entry in the junction table.
Therefore, if you want to remove a part of a collection,
at first remove all, then save the rest you want to leave.


## Server

### Logic

```
+----------+
| Frontend | (server.js)
+----------+
    |
	| find a logic for the app
	| 
    |    +---------+
	+--->|  Logic  |
         +---------+
```

### Container

### Model

### Sanitizing phase

### Validation phase

### Component overriding (Impl)

## Client

[FIG]

### Model

### CentralDispatch

### NotificationCenter

### KitchenSink made by Compoent
### Component made by Framework

### EditFormGroup
### SearchFormGroup

### List(Reusable)
### Editor(Reusable)
### SearchForm(Reusable)






